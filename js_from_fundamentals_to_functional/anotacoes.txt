#########################################################
Iteration
##########################################################

**** for in loops 
    
    - São especiais para objetos e todas as coisas em javascript são objetos
    - A variável usada no for recebe sempre a property name do objeto iterado
    - Não há garantia na ordem de leitura das propriedades do objeto

    Exemplo:

    =================================================================

    var box = {};

    box['material'] = 'cardboard'; //criando a propriedade no objeto usando a bracket notation
    box[0] = 'meow'; // no caso de usar um número, será criado no objeto uma propriedade chamada 0, isto é, o número será stringficado
    box['@#$%'] = 'testing 123'; //é possível utilizar caracteres especiais, desde que sejam colocados entre ' ou " , pois será stringficado
    

    for(var key in box){
    
        console.log(key); //aqui será exibido o nome da propriedade do objeto e não seu conteúdo
        console.log(box[key]); // para acessar o valor da propriedade é necessário utilizar o bracket notation
        console.log(box.key); //retornará undefined porque no caso de dotnotation, ele procurará dentro do objeto por uma propriedade chamada "key" e não pela propriedade com o mesmo nome do conteúdo dentro da variável key
    }

    =====================================================================


##########################################################
Igualdade em Javascript
##########################################################

    **** TRIPLE EQUAL
    O uso do triple equal é para uma comparação mais rigorosa (strict check), os tipos não são convertidos, e se forem diferentes (os tipos) o retorno é false, sem nem comparar o conteúdo
    if ('1' == 1) // isto retorna true, pois ele converte o inteiro para string e faz a comparação comparação
    
    **** DOUBLE EQUAL
    No caso do doble equal é para uma comparação mais branda, permissiva, nela os tipos são convertidos para um mesmo tipo e se o conteúdo for igual, o resultado é positivo .
    Usar o double equals pode trazer resultados inesperados! Por isso a recomendação é usar sempre o triple
    if ('1' === 1) // não tenta converter e como os tipos já são diferentes, o retorno é false

    **** Object.is
    Comportamento igual ao descrito no triplo equal, com diferença para tratamento de Nan e e -0 e +0
    Object.is(Nan, Nan) // retorna true enquanto nas demais tipos de comparação retorna false
    Object.is(-0, +0) // retorna false enquanto nas demais tipos de comparação retorna true


    Todas as diferenças entre as comparações são aplicáveis somente para os tipos primitivos, para objetos mesmo sendo estruturalmente iguais e com conteúdo iguais serão objetos diferentes, pois têm referências diferentes em memória
    
    https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Guide/Igualdade
    


